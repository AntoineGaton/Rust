{"message":"expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`","code":null,"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1058,"byte_end":1059,"line_start":48,"line_end":48,"column_start":22,"column_end":23,"is_primary":true,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":22,"highlight_end":23}],"label":"expected one of 7 possible tokens","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":1045,"byte_end":1052,"line_start":48,"line_end":48,"column_start":9,"column_end":16,"is_primary":false,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":9,"highlight_end":16}],"label":"while parsing the type for `new_arr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `=` if you meant to assign","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":1052,"byte_end":1053,"line_start":48,"line_end":48,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":" =","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:48:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let new_arr: [i32,3] = [];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of 7 possible tokens\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mhelp: use `=` if you meant to assign\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mwhile parsing the type for `new_arr`\u001b[0m\n\n"}
{"message":"expected value, found builtin type `i32`","code":{"code":"E0423","explanation":"An identifier was used like a function name or a value was expected and the\nidentifier exists but it belongs to a different namespace.\n\nErroneous code example:\n\n```compile_fail,E0423\nstruct Foo { a: bool };\n\nlet f = Foo();\n// error: expected function, tuple struct or tuple variant, found `Foo`\n// `Foo` is a struct name, but this expression uses it like a function name\n```\n\nPlease verify you didn't misspell the name of what you actually wanted to use\nhere. Example:\n\n```\nfn Foo() -> u32 { 0 }\n\nlet f = Foo(); // ok!\n```\n\nIt is common to forget the trailing `!` on macro invocations, which would also\nyield this error:\n\n```compile_fail,E0423\nprintln(\"\");\n// error: expected function, tuple struct or tuple variant,\n// found macro `println`\n// did you mean `println!(...)`? (notice the trailing `!`)\n```\n\nAnother case where this error is emitted is when a value is expected, but\nsomething else is found:\n\n```compile_fail,E0423\npub mod a {\n    pub const I: i32 = 1;\n}\n\nfn h1() -> i32 {\n    a.I\n    //~^ ERROR expected value, found module `a`\n    // did you mean `a::I`?\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1055,"byte_end":1058,"line_start":48,"line_end":48,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":19,"highlight_end":22}],"label":"not a value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0423]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: expected value, found builtin type `i32`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:48:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let new_arr: [i32,3] = [];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a value\u001b[0m\n\n"}
{"message":"pattern requires 2 elements but array has 0","code":{"code":"E0527","explanation":"The number of elements in an array or slice pattern differed from the number of\nelements in the array being matched.\n\nExample of erroneous code:\n\n```compile_fail,E0527\nlet r = &[1, 2, 3, 4];\nmatch r {\n    &[a, b] => { // error: pattern requires 2 elements but array\n                 //        has 4\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\nEnsure that the pattern is consistent with the size of the matched\narray. Additional elements can be matched with `..`:\n\n```\nlet r = &[1, 2, 3, 4];\nmatch r {\n    &[a, b, ..] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1054,"byte_end":1061,"line_start":48,"line_end":48,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":18,"highlight_end":25}],"label":"expected 0 elements","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0527]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: pattern requires 2 elements but array has 0\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:48:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let new_arr: [i32,3] = [];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 elements\u001b[0m\n\n"}
{"message":"invalid left-hand side of assignment","code":{"code":"E0070","explanation":"An assignment operator was used on a non-place expression.\n\nErroneous code examples:\n\n```compile_fail,E0070\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\n\nconst SOME_CONST: i32 = 12;\n\nfn some_other_func() {}\n\nfn some_function() {\n    SOME_CONST = 14; // error: a constant value cannot be changed!\n    1 = 3; // error: 1 isn't a valid place!\n    some_other_func() = 4; // error: we cannot assign value to a function!\n    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used\n                        //        like a variable!\n}\n```\n\nThe left-hand side of an assignment operator must be a place expression. A\nplace expression represents a memory location and can be a variable (with\noptional namespacing), a dereference, an indexing expression or a field\nreference.\n\nMore details can be found in the [Expressions] section of the Reference.\n\n[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n\nAnd now let's give working examples:\n\n```\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\nlet mut s = SomeStruct { x: 0, y: 0 };\n\ns.x = 3; // that's good !\n\n// ...\n\nfn some_func(x: &mut i32) {\n    *x = 12; // that's good !\n}\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1059,"byte_end":1060,"line_start":48,"line_end":48,"column_start":23,"column_end":24,"is_primary":false,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":23,"highlight_end":24}],"label":"cannot assign to this expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":1062,"byte_end":1063,"line_start":48,"line_end":48,"column_start":26,"column_end":27,"is_primary":true,"text":[{"text":"    let new_arr: [i32,3] = [];","highlight_start":26,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0070]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: invalid left-hand side of assignment\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:48:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let new_arr: [i32,3] = [];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mcannot assign to this expression\u001b[0m\n\n"}
{"message":"cannot index into a value of type `()`","code":{"code":"E0608","explanation":"An attempt to use index on a type which doesn't implement the `std::ops::Index`\ntrait was performed.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nTo be able to index into a type it needs to implement the `std::ops::Index`\ntrait. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1072,"byte_end":1082,"line_start":49,"line_end":49,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    new_arr[0] = 0;","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to access tuple elements, use","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":1072,"byte_end":1082,"line_start":49,"line_end":49,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"    new_arr[0] = 0;","highlight_start":5,"highlight_end":15}],"label":null,"suggested_replacement":"new_arr.0","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0608]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot index into a value of type `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:49:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    new_arr[0] = 0;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: to access tuple elements, use: `new_arr.0`\u001b[0m\n\n"}
{"message":"cannot index into a value of type `()`","code":{"code":"E0608","explanation":"An attempt to use index on a type which doesn't implement the `std::ops::Index`\ntrait was performed.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nTo be able to index into a type it needs to implement the `std::ops::Index`\ntrait. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n"},"level":"error","spans":[{"file_name":"src\\main.rs","byte_start":1107,"byte_end":1117,"line_start":50,"line_end":50,"column_start":20,"column_end":30,"is_primary":true,"text":[{"text":"    println!(\"{}\", new_arr[0]);","highlight_start":20,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to access tuple elements, use","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":1107,"byte_end":1117,"line_start":50,"line_end":50,"column_start":20,"column_end":30,"is_primary":true,"text":[{"text":"    println!(\"{}\", new_arr[0]);","highlight_start":20,"highlight_end":30}],"label":null,"suggested_replacement":"new_arr.0","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0608]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot index into a value of type `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:50:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    println!(\"{}\", new_arr[0]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: to access tuple elements, use: `new_arr.0`\u001b[0m\n\n"}
{"message":"aborting due to 6 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 6 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0070, E0423, E0527, E0608.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0070, E0423, E0527, E0608.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0070`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0070`.\u001b[0m\n"}
